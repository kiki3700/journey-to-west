---
title: Java Execution
slug: "java-execution"
---
자바는 컴파일 방식과 인터프리터 방식을 결합한 독특한 언어입니다. 자바 소스 파일(`.java`)은 먼저 컴파일러에 의해 바이트코드로 변환됩니다. 이 바이트코드는 중간 코드 형태로 `.class` 파일에 저장되며, 자바 가상 머신(JVM)에서 실행됩니다. JVM은 이 바이트코드를 인터프리터와 JIT(Just-In-Time) 컴파일러를 통해 실행합니다.

## 컴파일 과정: 바이트코드 생성

자바 컴파일러(`javac`)는 자바 소스 파일을 컴파일하여 바이트코드로 변환합니다. 이 과정에서 `.java` 파일은 `.class` 파일로 변환되며, 이 파일은 JVM에서 실행될 준비가 된 바이트코드를 포함합니다. 바이트코드는 자바 프로그램의 플랫폼 독립성을 보장하며, 다양한 운영 체제에서 동일하게 실행될 수 있습니다.

## JVM의 구조

JVM은 다음과 같은 주요 구성 요소로 이루어져 있습니다:

- **클래스 로더(ClassLoader)**: 컴파일된 바이트코드를 JVM 메모리로 로드하는 역할을 담당합니다.
- **메모리 관리(Heap, Stack)**: 객체를 저장하는 힙(Heap) 영역과 메서드 호출 시 사용되는 스택(Stack) 영역으로 구분됩니다.
- **실행 엔진(Execution Engine)**: 바이트코드를 읽고 실행하는 엔진으로, 인터프리터와 JIT 컴파일러가 포함됩니다.
- **가비지 컬렉터(Garbage Collector)**: 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리를 관리합니다.
- **네이티브 메서드 인터페이스(JNI)**: 자바 코드에서 네이티브 코드(C, C++)를 호출할 수 있도록 지원합니다.

## 클래스 로더: 바이트코드를 JVM에 로드

컴파일된 바이트코드는 클래스 로더(ClassLoader)에 의해 JVM 메모리에 로드됩니다. 클래스 로더는 다음의 역할을 수행합니다:

- **바이트코드 로드**: 컴파일된 클래스 파일을 JVM 메모리에 올립니다.
- **링킹(Linking)**: 로드된 클래스가 실행될 수 있도록 준비합니다. 이 단계에는 다음이 포함됩니다:
  - **바이트코드 검증(Verification)**: 보안상의 문제를 방지하기 위해 바이트코드를 검토합니다.
  - **메모리 할당(Preparation)**: 정적 변수(static variables)에 메모리를 할당합니다.
  - **심볼릭 참조 해제(Resolution)**: 심볼릭 메모리 참조를 실제 메모리 주소로 교체합니다.
- **정적 초기화(Initialization)**: 정적 변수에 초기값을 할당하고, 정적 블록을 실행합니다.

### 클래스 로더의 종류:

- **Bootstrap ClassLoader**: JVM의 기본 클래스 로더로, Java API의 핵심 클래스를 로드합니다 (예: `java.lang.*` 패키지).
- **Extension ClassLoader**: JVM이 시작될 때 설정된 확장 클래스들을 로드합니다 (예: `java.ext.*` 패키지).
- **Application ClassLoader**: 애플리케이션의 클래스패스에 지정된 클래스들을 로드합니다. 개발자가 작성한 클래스 파일들이 주로 이 로더에 의해 로드됩니다.

이 클래스 로더들은 계층 구조로 동작하며, 클래스 로딩 요청이 하위 로더에서 상위 로더로 위임되는 방식으로 작동합니다.

## 실행 엔진: 바이트코드 실행

JVM의 실행 엔진(Execution Engine)은 메모리에 로드된 바이트코드를 읽고, 이를 기계어로 변환하여 실행합니다. 실행 엔진은 다음과 같은 요소로 구성됩니다:

- **인터프리터(Interpreter)**: 바이트코드를 한 줄씩 읽어 기계어로 변환하고, 실행합니다. 이 방식은 초기 실행 속도가 느릴 수 있습니다.
- **JIT 컴파일러(Just-In-Time Compiler)**: 인터프리터의 속도 문제를 보완하기 위해 등장한 JIT 컴파일러는 자주 실행되는 코드(핫스팟)를 기계어로 미리 컴파일하여 성능을 최적화합니다. JIT 컴파일러는 프로파일러를 사용해 실행 중인 코드의 성능 데이터를 수집하고, 이를 기반으로 최적화할 코드를 선택합니다.
- **가비지 컬렉터(Garbage Collector)**: 실행 중에 동적으로 할당된 메모리를 관리하며, 더 이상 사용되지 않는 객체를 메모리에서 제거합니다.

### 가비지 컬렉터의 종류:

- **Serial GC**: 단일 스레드를 사용하여 가비지 컬렉션을 수행합니다. 작은 애플리케이션에 적합합니다.
- **Parallel GC**: 다수의 스레드를 사용하여 가비지 컬렉션을 병렬로 수행하여 성능을 향상시킵니다.
- **G1 GC (Garbage-First GC)**: 큰 힙을 효율적으로 관리할 수 있는 GC로, 짧은 멈춤 시간을 목표로 설계되었습니다.
- **ZGC (Z Garbage Collector)**: 매우 큰 힙에서도 짧은 멈춤 시간(수 밀리초 이내)을 보장하는 최신 GC입니다. 최근 대규모 애플리케이션에서 실험적으로 사용되고 있습니다.

현재 많은 JVM 애플리케이션에서 기본으로 사용되는 가비지 컬렉터는 **G1 GC**입니다. 이는 짧은 멈춤 시간과 효율적인 메모리 관리를 동시에 제공합니다.

## JNI: 네이티브 메소드 지원

자바는 또한 **JNI(Java Native Interface)**를 통해 네이티브 메소드 라이브러리(주로 C/C++로 작성된 코드)를 호출할 수 있습니다. 이를 통해 자바 프로그램은 JVM 외부에서 실행되는 네이티브 코드를 사용할 수 있습니다. 이 기능은 성능을 최적화하거나, 자바로 구현하기 어려운 작업을 네이티브 코드로 처리할 때 유용합니다.

## JIT 컴파일러: 인터프리터의 한계 극복

JIT 컴파일러는 인터프리터 방식의 단점을 보완하기 위해 도입되었습니다. 인터프리터는 바이트코드를 한 줄씩 읽고 실행하기 때문에 초기 실행 속도가 느리지만, JIT 컴파일러는 실행 중에 자주 사용되는 코드(핫스팟)를 기계어로 컴파일하여 성능을 크게 향상시킵니다.

### JIT 컴파일러의 최적화 기법:

- **인라인 최적화(Inline Optimization)**: 메소드 호출을 제거하고, 호출된 메소드의 코드를 호출 위치에 직접 삽입하여 성능을 향상시킵니다.
- **루프 언롤링(Loop Unrolling)**: 반복문의 루프 횟수를 줄여 실행 시간을 단축시킵니다.
- **동적 메소드 디스패치 최적화(Dynamic Method Dispatch Optimization)**: 런타임에 메소드 호출을 최적화하여 다형성의 성능 부담을 줄입니다.

JIT 컴파일러는 프로파일러로부터 수집된 실행 정보를 바탕으로, 최적화가 필요한 부분을 선택적으로 기계어로 변환하여 프로그램의 실행 속도를 최적화합니다.

