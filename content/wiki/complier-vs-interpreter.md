---
title: 컴파일러와 인터프리터
slug: "compile-vs-interpreter"
---

## 정의

- **소스코드**, **라이브러리**, **리소스** 등을 **컴파일**, **링크**, **패키징**하는 일련의 과정을 거쳐, 특정 환경에서 실행 가능한 **실행 파일**이나 배포 가능한 **소프트웨어 패키지**로 변환하는 작업을 말한다.

## 프로그래밍 언어의 구현 방식 차이에 따른 빌드 방법

- 컴파일러 방식(Complied Language): 소스코드를 한 번에 기계어로 변환하여 실행 파일을 생성하는 방식
  - 전처리, 컴파일, 어셈블러, 링킹 단계를 거쳐 빌드가 진행된다.
  - 이미 기계어로 번역되어 실행속도가 가장 빠르다는 장점이 있지만, 컴파일시 특정 플랫폼(cpu, os)에 맞춰 빌드가 진행되기 때문에 플랫폼에 종속적이고, 빌드시 시간비용이 많이드는 단점이 있다.
- 인터프리터 방식(Interpreted Language): 소스코드를 실행 시점에 한 줄씩 해석 하며, 즉시 실행하는 방식, 별도의 컴파일 과정이 없으며, 실행 할때마다 인터프리터가 소스 코드를 읽고 실행한다.
  - 직접 기계어를 실행하는 컴파일 방식보다 느리다는 단점이 있지만, 빌드 비용이 들지 않고, 플랫폼에 맞는 인터프리터만 설치하면, 어디서는 코드를 실행할 수 있다.
- 하이브리드 방식(Hybrid Languate): 컴파일러와 인터프리터 방식을 결합한 형태로, 보통 소스 코드 중간 코드(예: 바이트 코드)로 컴파일 한 후 그 중간 코드를 인터프리터가 실행하는 방식으로 동작한다. 두 가지 접근법의 장점을 결합하여, 효율적인 실행과 개발의 유연성을 모두 제공한다.

## 컴파일 방식

### 1. 전처리(Preprocessing)

**전처리**는 컴파일의 첫 번째 단계로, 소스 코드에 있는 전처리 지시문(주로 #으로 시작하는 지시문들)을 처리합니다. 예를 들어, C/C++의 #include, #define, #ifdef 같은 지시문이 이 단계에서 처리됩니다.

전처리 결과는 주석이 제거되고, 매크로가 확장되며, #include 지시문에 의해 포함된 파일들이 삽입된 소스 코드입니다.

### 2. 컴파일(Compilation)

이 단계에서는 소스 코드가 어셈블리 코드로 변환됩니다. 컴파일러는 소스 코드를 분석하여 어휘 분석, 구문 분석, 의미 분석을 거친 후, 이를 기반으로 어셈블리 코드를 생성합니다.

**어휘 분석(Lexical Analysis):** 소스 코드를 토큰(token)이라는 기본적인 단위로 분해합니다. 예를 들어, 키워드, 변수 이름, 연산자 등이 토큰이 됩니다.

**구문 분석(Syntax Analysis):** 토큰들의 조합이 언어의 문법에 맞는지를 검사합니다. 이 과정에서 구문 트리(parse tree)나 추상 구문 트리(Abstract Syntax Tree, AST)을 생성합니다.

**의미 분석(Semantic Analysis):** 구문적으로는 올바른 코드가 의미적으로도 올바른지 검사합니다. 예를 들어, 변수의 타입 일치 여부나, 선언되지 않은 변수의 사용 등을 체크합니다.

이 단계에서 소스 코드가 플랫폼 독립적인 중간 코드나 어셈블리 코드로 변환됩니다. 중간 코드는 보통 기계어에 가깝지만, 아직 완전한 기계어는 아닙니다.

### 3. 최적화(Optimization)

컴파일러는 생성된 중간 코드나 어셈블리 코드에 대해 최적화를 수행합니다. 이 단계는 필수는 아니지만, 성능을 향상시키기 위해 흔히 사용됩니다.

코드 최적화는 불필요한 코드 제거, 루프 최적화, 인라인 함수 삽입, 상수 폴딩 등 다양한 기법을 포함합니다.
최적화는 컴파일 타임에 추가 시간을 필요로 할 수 있지만, 최종 실행 파일의 크기를 줄이고 실행 속도를 높일 수 있습니다.

### 4. 어셈블리(Assembly)

**어셈블리 단계**에서는 어셈블리 코드가 **기계어(Machine Code)** 로 변환됩니다. 어셈블리 코드는 여전히 사람이 읽을 수 있는 형태의 저수준 언어지만, 기계어는 CPU가 직접 이해하고 실행할 수 있는 바이너리 코드입니다.

**어셈블러(Assembler)** 는 이 과정을 담당하며, 어셈블리어를 각 CPU의 명령어 집합에 맞는 기계어로 변환합니다.

### 5. 링크(Linking)

**링크 단계**에서는 여러 개의 객체 파일(object files)과 라이브러리들이 하나의 실행 가능한 파일로 결합됩니다.

이 과정에서 링커는 각 객체 파일의 함수나 변수 참조를 연결하고, 외부 라이브러리와의 연결 작업도 수행합니다.
정적 링크와 동적 링크가 있습니다:

**정적 링크(Static Linking):** 모든 필요한 코드가 실행 파일에 포함됩니다. 이 파일은 독립적으로 실행될 수 있지만, 크기가 커질 수 있습니다.

**동적 링크(Dynamic Linking):** 필요한 라이브러리 코드가 실행 파일에 포함되지 않고, 실행 시점에 외부 라이브러리를 참조합니다. 이 방식은 실행 파일의 크기를 줄일 수 있지만, 해당 라이브러리가 실행 환경에 존재해야 합니다.

### 6. 최종 실행 파일 생성

링크 과정이 끝나면, 최종적으로 독립적인 실행 파일이 생성됩니다. 이 파일은 특정 운영 체제나 하드웨어에서 실행될 수 있는 형태의 바이너리 파일입니다.

생성된 실행 파일은 운영 체제의 로더(Loader)에 의해 메모리에 적재되고 실행됩니다.
