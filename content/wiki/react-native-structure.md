---
title: "React Native 구조"
slug: "react-nateive-structure"
---

## **1\. 런타임 및 렌더링 구조**

리액트 네이티브는 자바스크립트 로직을 사용하여 네이티브 UI를 제어하는 프레임워크입니다. 웹뷰(WebView) 방식과는 달리 실제 플랫폼의 네이티브 뷰를 생성합니다.

- **Host (Platform):** 모바일 운영체제인 iOS와 Android를 의미합니다.
- **View (Native Widgets):** 리액트 네이티브의 \<View\> 컴포넌트는 렌더링 시점에 HTML의 div가 아닌, 각 플랫폼의 네이티브 UI 인스턴스를 생성합니다.
  - **Android:** android.view.ViewGroup
  - **iOS:** UIView
- **특징:** 애플리케이션의 비즈니스 로직은 자바스크립트 엔진에서 수행되지만, 최종적인 UI 렌더링은 운영체제의 네이티브 UI 시스템이 담당합니다.

## **2\. 실행 모델과 스레드 (Concurrency Model)**

리액트 네이티브는 원활한 동작을 위해 작업을 분리된 스레드에서 처리합니다.

1. **Main Thread (UI Thread):** 네이티브 애플리케이션의 메인 스레드입니다. UI 렌더링과 사용자 제스처(터치, 스크롤 등) 이벤트를 처리합니다.
2. **JavaScript Thread:** 개발자가 작성한 리액트 로직, 비즈니스 로직, API 호출, 상태 관리 등이 실행되는 스레드입니다.
3. **Shadow Thread (Background):** 레이아웃 계산을 담당하는 스레드입니다. 자바스크립트에서 작성된 Flexbox 레이아웃을 네이티브 플랫폼이 이해할 수 있는 절대 좌표와 크기(픽셀 값)로 변환합니다. (Yoga 엔진 사용)

## **3\. 엑스포(Expo)와 CLI의 차이**

개발 환경 및 빌드 설정의 제어 범위에 따른 구분입니다.

- **React Native CLI (Bare Workflow):**
  - 개발자가 android 및 ios 디렉토리 내의 네이티브 프로젝트 파일(Gradle, Podfile, Info.plist 등)을 직접 구성하고 관리해야 합니다.
  - 네이티브 모듈 추가 시 링킹 설정 및 의존성 관리가 개발자의 몫입니다.
- **Expo:**
  - 네이티브 프로젝트 파일을 추상화하여 관리합니다.
  - 자주 사용되는 네이티브 모듈(카메라, 위치 등)이 포함된 SDK(Expo Go)를 제공하거나, Prebuild 기능을 통해 빌드 시점에 네이티브 코드를 동적으로 생성합니다.

## **4\. 스레드 통신 방식**

자바스크립트 실행 환경과 네이티브 실행 환경은 메모리를 공유하지 않으므로 별도의 통신 메커니즘이 필요합니다.

### **4.1. 기존 방식: 브릿지 (The Bridge)**

구형 아키텍처에서 사용되던 방식입니다.

- **통신 방식:** 비동기(Asynchronous) 메시지 큐 방식입니다.
- **데이터 포맷:** JSON 문자열.
- **작동 원리:**
  1. JS 스레드에서 네이티브 호출 요청을 직렬화(Serialization)하여 JSON 메시지로 변환합니다.
  2. 브릿지를 통해 메시지를 전달합니다.
  3. 네이티브 스레드에서 메시지를 수신 후 역직렬화(Deserialization)하여 명령을 수행합니다.
- **한계:** 대량의 데이터 전송이나 고빈도 이벤트(스크롤, 애니메이션) 발생 시 직렬화/역직렬화 비용으로 인한 병목 현상이 발생하여 프레임 드롭이나 반응 지연의 원인이 됩니다.

### **4.2. 개선된 방식: JSI (JavaScript Interface)**

새로운 아키텍처(Fabric, TurboModules)의 핵심 기술입니다.

- **핵심 개념:** 직접 참조 (Direct Reference).
- **작동 원리:** C++로 작성된 Host Object를 통해 자바스크립트 엔진이 네이티브 메모리 영역의 함수나 객체를 직접 참조하고 호출합니다.
- **특징:** 브라우저 콘솔에서 DOM API를 호출하듯, 자바스크립트가 네이티브 메서드를 동기적으로 즉시 실행할 수 있습니다. 별도의 직렬화 과정이 불필요합니다.

## **5\. UI 렌더링과 동기 처리의 중요성**

UI 업데이트는 16ms(60fps 기준) 내에 완료되어야 부드러운 사용자 경험을 제공할 수 있습니다.

- **비동기(Bridge)의 한계:** 사용자 제스처(Native)와 이에 따른 로직 처리(JS) 사이에 메시지 전달 및 대기 시간이 존재합니다. 이로 인해 터치 반응 속도가 느려지거나 UI가 제스처를 따라오지 못하는 지연(Latency)이 발생할 수 있습니다.
- **동기(JSI)의 이점:** 네이티브 이벤트 발생 시 JS 함수를 동기적으로 즉시 호출하여 로직을 수행하고 UI를 업데이트할 수 있습니다. 이를 통해 네이티브 앱과 동일한 수준의 반응성을 확보합니다.

## **6\. 빌드 및 런타임 구조**

리액트 네이티브 앱은 '네이티브 바이너리'와 'JS 번들'의 결합으로 구성됩니다.

### **6.1. 빌드 단계 (Build Time)**

두 가지 과정이 병렬로 진행된 후 결합됩니다.

1. **네이티브 빌드:**
   - Android(Gradle)와 iOS(Xcode) 빌드 도구를 사용하여 네이티브 코드를 컴파일합니다.
   - 이 과정에서 JS 엔진(Hermes, JSC 등)이 포함된 앱 실행 파일(APK/IPA)이 생성됩니다.
2. **JS 번들링:**
   - Metro Bundler가 JS/TS 파일들을 하나의 파일(index.bundle)로 병합합니다.
   - 일반적으로 컴파일되지 않은 스크립트 형태이거나, Hermes 사용 시 바이트코드로 변환됩니다.
3. **결합:**
   - 생성된 JS 번들 파일이 네이티브 앱의 에셋(Assets) 디렉토리에 포함됩니다.

### **6.2. 런타임 단계 (Run Time)**

앱 실행 시의 동작 과정입니다.

1. **네이티브 실행:** OS가 앱 프로세스를 생성하고 네이티브 실행 환경을 메모리에 로드합니다.
2. **JS 엔진 초기화:** 앱 내부의 자바스크립트 엔진(Hermes 등)을 구동합니다.
3. **번들 로드:** 에셋에 포함된 JS 번들 파일을 엔진이 읽어들이고 파싱(Parsing)합니다.
4. **UI 렌더링:** JS 코드가 실행되면서 브릿지 또는 JSI를 통해 네이티브 측에 UI 생성 명령을 전달하고 화면을 그립니다.

### **6.3. 구조적 특징**

- **Code Push 가능:** 비즈니스 로직이 JS 번들(파일) 형태로 존재하므로, 네이티브 바이너리 재배포 없이 번들 파일 교체만으로 앱 업데이트가 가능합니다.
- **초기 구동 시간:** 네이티브 코드를 즉시 실행하는 방식과 달리, JS 엔진 초기화 및 번들 로딩 과정이 필요하므로 초기 실행 속도(Warm-up time) 최적화가 중요합니다. (Hermes 엔진이 이를 개선함)
