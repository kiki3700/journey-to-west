---
title: Item 6. 불필요한 객체 생성을 피하라
slug: "effective-java-item-6"
---

### 불필요한 객체 생성 방지

불필요한 객체 생성을 줄이는 것은 특히 자원이 많이 소모되는 애플리케이션에서 성능 문제를 방지하는 데 중요합니다. 동일한 객체를 반복적으로 생성하기보다는 기존 객체를 재사용하는 것이 더 효율적입니다. 아래는 불필요한 객체 생성을 최소화하기 위한 지침과 예제입니다.

---

#### 1. 문자열 리터럴 사용

문자열을 생성할 때 `new String()` 대신 문자열 리터럴을 사용하는 것이 좋습니다. 문자열 리터럴은 문자열 풀(String Pool)에 저장되어 동일한 값을 가진 문자열을 재사용할 수 있습니다.

**예제:**

```java
// 비효율적: 매번 새로운 String 객체를 생성
String str1 = new String("안녕하세요");
String str2 = new String("안녕하세요"); // 새로운 객체 생성

// 효율적: 문자열 풀에서 동일 객체를 재사용
String str1 = "안녕하세요";
String str2 = "안녕하세요"; // 동일 객체 재사용

// 메모리 동작:
// "안녕하세요" 객체는 문자열 풀에 한 번만 저장되며 str1과 str2는 이를 참조합니다.
```

---

---

#### 문자열이 메모리에 저장되는 방식

- **문자열 풀(String Pool):** Java는 문자열 리터럴을 힙 메모리 영역 속 특별한 메모리 영역인 문자열 풀에 저장합니다. 새로운 문자열 리터럴이 생성되면 Java는 동일한 문자열이 풀에 존재하는지 확인하고, 존재하면 기존 객체를 재사용하며, 없으면 새 객체를 생성해 풀에 추가합니다.

**예제:**

```java
String s1 = "예제";
String s2 = "예제"; // s1의 객체 재사용

String s3 = new String("예제"); // 풀 외부에 새로운 객체 생성

// 메모리 동작:
// s1과 s2는 문자열 풀의 동일 객체를 참조
// s3는 힙 영역의 별도 객체를 참조
```

---

#### 2. 정적 팩토리 메서드 사용

정적 팩토리 메서드는 새로운 객체를 생성하는 대신 기존 객체를 반환하여 불필요한 객체 생성을 줄일 수 있습니다.

**예제:**

```java
// Boolean.valueOf를 사용하여 인스턴스 재사용
Boolean b1 = Boolean.valueOf(true); // 미리 생성된 인스턴스 재사용
Boolean b2 = Boolean.valueOf(true); // b1과 동일 인스턴스 반환

// 비효율적 대안:
Boolean b1 = new Boolean(true); // 새로운 객체 생성
Boolean b2 = new Boolean(true); // 또 다른 새로운 객체 생성
```

**설명:**

- `Boolean.valueOf(true)`는 캐싱된 `Boolean.TRUE` 인스턴스를 반환합니다.
- 이를 통해 동일 값에 대해 여러 Boolean 객체를 생성하지 않습니다.

---

#### 3. 클래스 초기화 과정에서 객체 캐싱

생성이 비용이 많이 들고 자주 사용되는 객체는 한 번 초기화하여 캐싱한 후 재사용하는 것이 좋습니다.

**예제:**

```java
// 비효율적: 매번 새로운 Date 객체 생성
public class DateUtility {
    public Date getCurrentDate() {
        return new Date();
    }
}

// 효율적: 객체를 캐싱하여 재사용
public class DateUtility {
    private static final Date EPOCH_DATE = new Date(0); // 캐싱된 인스턴스

    public static Date getEpochDate() {
        return EPOCH_DATE;
    }
}
```

**설명:**

- `EPOCH_DATE`를 캐싱하여 동일한 값의 `Date` 객체를 여러 번 생성하지 않도록 합니다.

---

#### 4. 오토박싱 오버헤드 방지

기본 타입과 래퍼 클래스를 변환할 때 오토박싱은 불필요한 객체를 생성할 수 있습니다. 가능한 경우 기본 타입을 사용하는 것이 좋습니다.

**예제:**

```java
// 비효율적: 오토박싱으로 인해 불필요한 Integer 객체 생성
Integer sum = 0;
for (int i = 0; i < 1000; i++) {
    sum += i; // 매 반복마다 오토박싱 발생
}

// 효율적: 기본 타입 사용
int sum = 0;
for (int i = 0; i < 1000; i++) {
    sum += i;
}
```

**설명:**

- 첫 번째 예제에서는 각 덧셈 연산에서 새로운 `Integer` 객체가 생성됩니다.
- 기본 타입을 사용하면 이러한 오버헤드를 방지할 수 있습니다.

위의 지침을 따르면 불필요한 객체 생성을 줄이고 애플리케이션 성능을 향상시킬 수 있습니다.
